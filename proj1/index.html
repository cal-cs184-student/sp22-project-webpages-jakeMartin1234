<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>Project 1 ~ Rasterizer</title>
        <link rel="icon" type="image/x-icon" href="assets/TriangleIcon.png" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="css/styles.css" rel="stylesheet" />
    </head>
    <body id="page-top">
        <!-- Navigation-->
        <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top" id="mainNav">
            <div class="container px-4">
                <a class="navbar-brand" href="#page-top">CS 184 Project 1 ~ Rasterizer</a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
                <div class="collapse navbar-collapse" id="navbarResponsive">
                    <ul class="navbar-nav ms-auto">
                        <li class="nav-item"><a class="nav-link" href="#about">About Project</a></li>
                        <li class="nav-item"><a class="nav-link" href="#Part1">Part 1</a></li>
                        <li class="nav-item"><a class="nav-link" href="#Part2">Part 2</a></li>
                        <li class="nav-item"><a class="nav-link" href="#Part3">Part 3</a></li>
                        <li class="nav-item"><a class="nav-link" href="#Part4">Part 4</a></li>
                        <li class="nav-item"><a class="nav-link" href="#Part5">Part 5</a></li>
                        <li class="nav-item"><a class="nav-link" href="#Part6">Part 6</a></li>
                    </ul>
                </div>
            </div>
        </nav>
      
      
        <!-- About Section -->
        <section id="about">
            <div class="container px-4">
                <div class="row gx-4 justify-content-center">
                    <div class="col-lg-8">
                        <h2>About the project</h2>
                        <p class="lead">In this project I sucessfully programmed a rasterizer which can effectively carry out Supersampling, Texture Mapping using barycentric co-ordinates and mipmaps which are beneficial for optimizing textures without using the strenuous amout of computational power that supersampling requires.</p>
                        <p style="text-align:center;"><img src="assets/Sphere.png" alt="Sphere Main" style="width: 40%;"></p>
                    </div>
                </div>
            </div>
        </section>
        <!-- Part 1 -->
        <section class="bg-light" id="Part1">
            <div class="container px-4">
                <div class="row gx-4 justify-content-center">
                    <div class="col-lg-8">
                        <h2>Part 1 - Drawing Single Colored Triangles</h2>
                        <p class="lead">I implemented this part by creating a box around the 
                        triangle made from its minimum and maximum x and y values. Then I used the inside() function from triangulation.cpp.
                        If the inside() function returns false for the center of the triangle, I then switched two of the vertices that are input into the 
                        inside function to change the direction of rotation around the 3 points.</p>
                        <p class="lead">As you can see in the photo below, the triangles are rasterizing correctly but there is still alot of aliasing present due to the low sample rate.</p>
                        <p style="text-align:center;"><img src="assets/Part1-Photo1.png" alt="Sphere Main" style="width: 100%;"></p>
                    </div>
                </div>
            </div>
        </section>
        <!-- Part 2-->
        <section id="Part2">
            <div class="container px-4">
                <div class="row gx-4 justify-content-center">
                    <div class="col-lg-8">
                        <h2>Part 2: Antialiasing by Supersampling</h2>
                        <p class="lead">In this task I improved on the program that I had written in part 2 by implementing supersampling. I did this by enlargening the sample buffer by a factor of the sample rate. For each pixel/element in the buffer I used the inside test in the same was as I did in part 1 to determine whether it gets filled or not. After all of the triangles on the screen have been rasterized, the program then takes the average color of the pixels in the sample buffer and puts this color into the corresponding pixel in the final frame buffer</p>
                        <p style="text-align:center;"><img src="assets/Part2-Photo2.png" alt="Sphere Main" style="width: 100%;"></p>
                        <p style="text-align:center;"><img src="assets/Part2-Photo1.png" alt="Sphere Main" style="width: 100%;"></p>
                    </div>
                </div>
            </div>
        </section>
        <!-- Part 3 -->
        <section class="bg-light" id="Part3">
            <div class="container px-4">
                <div class="row gx-4 justify-content-center">
                    <div class="col-lg-8">
                        <h2>Part 3 - Transforms</h2>
                        <p class="lead">In this part I implemented rotation functions by perfoming these transforms with 3x3 matricies. The three transforms I implemented are rotate, scale and translate.</p>
                        <p class="lead">In the photo below got the robot to do a handstand. To do this I rotated the arms 90 degrees such that they are both pointing up. I then adjusted the positions of these arms so that they look attached to the body. I then rotated the legs 45 drgees outwards so that it looks like he is balancing. His head is slightly tilted too. After doing this I then rotated the whole robot 180 degrees so that he is upside down.</p>
                        <p style="text-align:center;"><img src="assets/Part3-Photo1.png" alt="Sphere Main" style="width: 60%;"></p>
                    </div>
                </div>
            </div>
        </section>
        <!-- Part 4 -->
        <section id="Part4">
            <div class="container px-4">
                <div class="row gx-4 justify-content-center">
                    <div class="col-lg-8">
                        <h2>Part 4 - Barycentric coordinates</h2>
                        <p class="lead">I implemented this part by creating a box around the 
                        triangle made from its minimum and maximum x and y values. Then I used the inside() function from triangulation.cpp.
                        If the inside() function returns false for the center of the triangle, I then switched two of the vertices that are input into the 
                        inside function to change the direction of rotation around the 3 points.</p>
                        <p style="text-align:center;"><img src="assets/ColorWheel.png" alt="Sphere Main" style="width: 60%;"></p>
                    </div>
                </div>
            </div>
        </section>
        <!-- Part 5 -->
        <section class="bg-light" id="Part5">
            <div class="container px-4">
                <div class="row gx-4 justify-content-center">
                    <div class="col-lg-8">
                        <h2>Part 5 - "Pixel Sampling" for texture mapping</h2>
                        <p class="lead">In this section of the project I implemented texture mapping using barycentric coordinates. For each point rasterized, I calulated the value of the barycentric coordinates retreived the value of the pixel with the equivalent barycentric coordinates defined by the triangle in the texture. The only issue with doing this is that it is an extremely small possibiltiy that the pixels in the trianlge on the texture are in the same locations. To solve this I programmed two methods to manage this issue. The nearest pixel method chooses the nearest pixel to the equivelent location of the pixel in the sample buffer. While this method makes sense, it still produces images with aliasing. This was aided by bilinear sampling. With this method the colors in the surrounding 4 pixels are combined with a color being more dominant if the continous point calculated by the barycentric coordinates is closer to it.</p>
                        <p style="text-align:center;"><img src="assets/Part5-Photo1.png" alt="Sphere Main" style="width: 60%;"></p>
                        <p style="text-align:center;"><img src="assets/Part5-Photo2.png" alt="Sphere Main" style="width: 60%;"></p>
                    </div>
                </div>
            </div>
        </section>
        <!-- Part 6 -->
        <section id="Part6">
            <div class="container px-4">
                <div class="row gx-4 justify-content-center">
                    <div class="col-lg-8">
                        <h2>Part 6 - "Level sampling" with mipmaps for texture mapping</h2>
                        <p class="lead">A mipmap is a data structure which stores a texture image at different resolutions, each of which have been pre-optimized so that a substantial amount of aliasing has been eliminated already at while not having much cost on the CPU at runtime. The first step of sampling a texture image is to determine the difference in distance between two adjacent barycentric co-ordinates in the texture image compared to the sample buffer. The larger this distance, the higher the mipmap level that is needed such that aliasing will be reduced due to small objects on the texture not getting randomly sampled causing random high frequency change in the image. These objects are blurred in the higher levels of the mipmap as they have already been sampled upon creation of the mipmap. This distance that determines the mipmap level increases as the size of the triangle in the sample buffer decreases in comparison with the size of the corresponding triangle in the texture image. The mipmap level is a non-negative integer. The height and width are 1 / 2<sup>(mipmap level)</sup> multiplied by the original height or width. This ensures that the photo has the same width/height ratio while also offering different resolutions of the photo.</p>
                        <p style="text-align:center;"><img src="assets/Part6-Photo1.png" alt="Sphere Main" style="width: 90%;"></p>
                        <p style="text-align:center;"><img src="assets/Part6-Photo2.png" alt="Sphere Main" style="width: 90%;"></p>
                    </div>
                </div>
            </div>
        </section>
        <!-- Bootstrap core JS-->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Core theme JS-->
        <script src="js/scripts.js"></script>
    </body>
</html>
